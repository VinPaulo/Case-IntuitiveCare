README também disponível em (Recomendado): [Notion - Documentação Teste Intuitive Care](https://www.notion.so/Documenta-o-Teste-Intuitive-Care-2f7a2dc96cf68046bf12ecef9f15886f?source=copy_link)

1. Contexto e Objetivo

O foco desse projeto foi pegar os dados da ANS, que estão todos espalhados e brutos, e transformar em um dashboard que realmente faça sentido para analisar as despesas das operadoras. 2. Visão Geral da Arquitetura

O sistema foi dividido em três partes: PostgreSQL para o banco, FastAPI no backend e Vue.js 3 + Chart.js para os gráficos.

Fluxo de Dados: Os dados passam por um ETL (extração e limpeza), são salvos de forma organizada no banco e a API entrega esses dados prontos para o frontend gerar os gráficos. 3. Execução do Projeto
3.1 Banco de Dados (PostgreSQL)

    Criar o banco ans_database.

    Rodar o script da pasta 03-BancoDeDados para criar as tabelas automaticamente.

3.2 Backend (FastAPI)

Local: Integração-API-publica/04-Interface/BackEnd

Configuração:

    Na raiz do projeto: cd /home/paulolemos/testes-estágio-intuitive_care

    Criar e ativar a venv:

        Linux: python3 -m venv venv && source venv/bin/activate

        Windows: python -m venv venv && .\venv\Scripts\activate

    Instalar os requisitos e rodar: pip install -r requirements.txt uvicorn main:app --reload

Link do Swagger: http://127.0.0.1:8000/docs
3.3 Frontend (Vue.js 3)

Na pasta FrontEnd: npm install npm run serve (Roda em http://localhost:8080) 4. Decisões Técnicas e Trade-offs
4.1 Processamento de Arquivos (ETL)

    Decisão: Usar Pandas processando em memória.

    Justificativa: Como os arquivos da ANS encaixam bem na memória de um PC atual, processar tudo de uma vez é muito mais rápido e facilita na hora de fazer limpezas mais chatas (como regex e joins), sem precisar ficar lendo o arquivo várias vezes.

4.2 Modelagem do Banco

    Decisão: Modelagem Normalizada.

    Justificativa: Separei as operadoras das despesas. É como separar o cadastro de um cliente das compras que ele faz: as compras aumentam todo dia, mas o cadastro muda pouco. Isso deixa o banco mais organizado e as consultas muito mais rápidas.

4.3 Precisão nos Valores

    Decisão: Usar DECIMAL(18,2) para os valores financeiros.

    Justificativa: Para mexer com dinheiro, não dá para usar FLOAT porque ele arredonda os valores de um jeito estranho. O DECIMAL garante que a conta feche certinho, centavo por centavo.

4.4 Framework Backend

    Decisão: FastAPI.

    Justificativa: Escolhi o FastAPI por ser assíncrono e muito veloz. Ele consegue lidar com várias requisições ao mesmo tempo sem travar, o que é ótimo para processar o volume de dados da ANS e ainda gerar a documentação (Swagger) na hora.

4.5 Paginação

    Decisão: Paginação via Offset.

    Justificativa: Pense na paginação como o sumário de um livro: o usuário pode querer pular direto para a última página se quiser. Para a quantidade de operadoras que temos, essa é a forma mais simples e direta de navegar.

4.6 Sistema de Busca

    Decisão: Busca feita no Servidor.

    Justificativa: Em vez de carregar tudo no navegador e filtrar lá, eu mando a busca para o banco (usando ILIKE). Assim, o usuário acha a operadora mesmo que ela esteja em outra página que ainda não foi carregada.

5. Backend e Processamento

   Lógica do "Plano B" no Join: Os arquivos da ANS são meio bagunçados: uns usam CNPJ e outros o Registro ANS. Para não perder dado no caminho, fiz uma lógica que tenta o cruzamento pelo CNPJ e, se não achar, tenta pelo Registro. Isso garantiu que a base ficasse completa.

   SQL na mão: Usei CAST em todas as conversões de tipo nas queries. Segui o que aprendi na faculdade para o código ficar limpo e profissional, evitando erros de compatibilidade entre as tabelas.

   Postman: Deixei o arquivo ANSDashboard-CaseIntuitiveCare.json na pasta /docs. Só importar no Postman para testar as rotas da API.

6. Frontend e Visualização

   Controle de Reatividade: Para evitar que o gráfico apareça vazio enquanto o banco responde, usei uma "chave". O componente do gráfico só é criado quando a API confirma que o dado chegou. Assim, o usuário não vê aquele frame em branco enquanto espera.
