Dashboard de Despesas - Operadoras de Saúde (ANS)
README também disponível em: Notion - Documentação Teste Intuitive Care

1. Contexto e Objetivo
Este projeto foi desenvolvido com o objetivo de transformar dados públicos e descentralizados da ANS em uma ferramenta visual para análise de despesas de operadoras de saúde.

2. Visão Geral da Arquitetura
O sistema é dividido em três camadas principais:

Banco de Dados: PostgreSQL

Backend: FastAPI (API REST)

Frontend: Vue.js 3 + Chart.js

Fluxo de Dados:

Os dados brutos da ANS passam por um processo de ETL.

São armazenados de forma normalizada no PostgreSQL.

A API expõe rotas analíticas e cadastrais.

O frontend consome esses dados e gera visualizações.

3. Execução do Projeto
3.1 Banco de Dados (PostgreSQL)
Criar um banco chamado ans_database.

Executar o script disponível na pasta 03-BancoDeDados para criação das tabelas.

3.2 Backend (FastAPI)
Localizado na pasta BackEnd.

Bash
# Criar e ativar o ambiente virtual
python -m venv venv
source venv/bin/scripts/activate # Windows: venv\Scripts\activate

# Instalar dependências
pip install -r requirements.txt

# Executar a API
uvicorn main:app --reload
Documentação interativa (Swagger): http://127.0.0.1:8000/docs

3.3 Frontend (Vue.js 3)
Localizado na pasta FrontEnd.

Bash
# Instalar dependências e rodar
npm install
npm run serve
Acesso local: http://localhost:8080

4. Decisões Técnicas e Trade-offs
4.1 Framework Backend FastAPI
Decisão: Uso do FastAPI.

Justificativa: Saindo um pouco do modelo tradicional, escolhi o FastAPI por ele ser assíncrono por natureza e extremamente veloz. Para um sistema que precisa processar grandes volumes de dados da ANS e entregar análises em tempo real, ele é ideal. Além disso, a documentação automática poupa um tempo precioso de integração.

4.2 Paginação baseada em OFFSET
Decisão: Opção A (Offset-based).

Justificativa: Pense na paginação como um sumário de um livro: o usuário quer ter a liberdade de pular direto para a última página se quiser. Como os dados cadastrais não mudam a cada segundo, o OFFSET é a solução mais simples e direta para garantir essa fluidez sem complicar a arquitetura.

4.3 Queries diretas no PostgreSQL
Decisão: Cálculos em tempo real.

Justificativa: Optei por processar a "inteligência" dos dados direto no banco. Como as queries foram otimizadas com índices, o Postgres entrega a resposta instantaneamente. Isso evita a necessidade de um cache, que poderia acabar mostrando um dado financeiro defasado — e em análise de despesas, precisão é tudo.

4.4 Mensagens de erro específicas
Decisão: Estados de erro detalhados.

Justificativa: Ninguém gosta de mensagens genéricas que não explicam nada. O sistema identifica se o problema é de rede, se a operadora não existe ou se os dados ainda não foram processados. É o conceito de "falhar com elegância", dando um feedback real para quem está usando.

5. Backend e Processamento de Dados
ETL (Pandas) e o Join Híbrido: Percebi que os arquivos da ANS são inconsistentes: uns usam CNPJ e outros o Registro ANS. Para não perder informação no meio do caminho, criei uma lógica que tenta o cruzamento por CNPJ e, se falhar, usa o Registro como "plano B". Isso garantiu a integridade total da base.

SQL (CTEs e Joins): Nas queries SQL, fiz questão de seguir o padrão que aprendi na faculdade, utilizando o CAST explícito em todas as conversões de tipos. Saindo um pouco da facilidade de usar atalhos específicos de um banco só, essa abordagem deixa o código mais 'limpo' e profissional, além de evitar erros de compatibilidade entre o CNPJ das despesas e o Registro das operadoras.

API REST: Deixei uma coleção do Postman pronta na pasta /docs. Ela mostra todo o ecossistema da API: desde a listagem simples até os endpoints analíticos que alimentam o dashboard.

5.1 Documentação da API (Postman)
Para facilitar a validação das rotas e entender a estrutura dos dados retornados, incluí uma coleção completa do Postman.

Como importar e testar:

Abra o Postman.

Clique no botão Import (canto superior esquerdo).

Arraste o arquivo ANSDashboard-CaseIntuitiveCare.json localizado na pasta /docs.

6. Frontend e Visualização
O Desafio da Reatividade: Um problema comum em dashboards é o gráfico aparecer vazio enquanto os dados carregam. Para resolver isso, usei uma "chave de reatividade": o componente do gráfico só "nasce" de verdade quando a API confirma que o dado chegou. Assim, a experiência visual é sempre limpa e sem aquele frame em branco que confunde o usuário.