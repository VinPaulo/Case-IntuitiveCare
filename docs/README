README também disponível em: https://www.notion.so/Documenta-o-Teste-Intuitive-Care-2f7a2dc96cf68046bf12ecef9f15886f?source=copy_link

No Notion está mais organizado e de fácil leitura. :) 


## 1. Contexto e Objetivo

Este projeto foi desenvolvido com o objetivo de transformar dados públicos e descentralizados da **ANS** em uma **ferramenta visual para análise de despesas de operadoras de saúde**.

O foco principal não foi apenas o desenvolvimento do código, mas a construção de um **pipeline completo**, priorizando:

- integridade e consistência dos dados,
- clareza na API,
- boa experiência para quem consome as informações no frontend.

O projeto é apresentado como **evidência técnica para avaliação em processo seletivo**.

## 2. Visão Geral da Arquitetura

O sistema é dividido em três camadas principais:

- **Banco de Dados:** PostgreSQL
- **Backend:** FastAPI (API REST)
- **Frontend:** Vue.js 3 + Chart.js

O fluxo de dados ocorre da seguinte forma:

1. Os dados brutos da ANS passam por um processo de ETL
2. São armazenados de forma normalizada no PostgreSQL
3. A API expõe rotas analíticas e cadastrais
4. O frontend consome esses dados e gera visualizações

## 3. Execução do Projeto

### 3.1 Banco de Dados (PostgreSQL)

- Criar um banco chamado `ans_database`
- Executar o script disponível na pasta `03-Banco-de-Dados` para criação das tabelas

### 3.2 Backend (FastAPI)

- Na pasta `BackEnd`, criar e ativar o ambiente virtual:
    
    ```bash
    python -m venv venv
    
    ```
    
- Instalar dependências:
    
    ```bash
    pip install -r requirements.txt
    
    ```
    
- Executar a API:
    
    ```bash
    uvicorn main:app --reload
    
    ```
    
- Documentação interativa (Swagger):
    
    ```
    http://127.0.0.1:8000/docs
    
    ```
    

### 3.3 Frontend (Vue.js 3)

- Na pasta `FrontEnd`:
    
    ```bash
    npm install
    npm run serve
    
    ```
    
- Acesso:
    
    ```
    http://localhost:8080
    
    ```
    

## 4. Decisões Técnicas e Trade-offs

Nesta etapa, foquei em tomar decisões que equilibrassem performance e clareza. Segue a justificativa das escolhas que fiz:

### **4.1 Framework Backend FastAPI**

- **Decisão:** Uso do FastAPI.
- **Justificativa:** Saindo um pouco do modelo tradicional, escolhi o FastAPI por ele ser assíncrono por natureza e extremamente veloz. Para um sistema que precisa processar grandes volumes de dados da ANS e entregar análises em tempo real, ele é ideal. Além disso, a documentação automática poupa um tempo precioso de integração.

### **4.2 Paginação baseada em OFFSET**

- **Decisão:** Opção A (Offset-based).
- **Justificativa:** Pense na paginação como um sumário de um livro: o usuário quer ter a liberdade de pular direto para a última página se quiser. Como os dados cadastrais não mudam a cada segundo, o `OFFSET` é a solução mais simples e direta para garantir essa fluidez sem complicar a arquitetura.

### **4.3 Queries diretas no PostgreSQL**

- **Decisão:** Cálculos em tempo real.
- **Justificativa:** Optei por processar a "inteligência" dos dados direto no banco. Como as queries foram otimizadas com índices, o Postgres entrega a resposta instantaneamente. Isso evita a necessidade de um cache, que poderia acabar mostrando um dado financeiro defasado — e em análise de despesas, precisão é tudo.

### **4.4 Mensagens de erro específicas**

- **Decisão:** Estados de erro detalhados.
- **Justificativa:** Ninguém gosta de mensagens genéricas que não explicam nada. O sistema identifica se o problema é de rede, se a operadora não existe ou se os dados ainda não foram processados. É o conceito de "falhar com elegância", dando um feedback real para quem está usando.

## 5. Backend e Processamento de Dados

Aqui foi onde desmistifiquei a bagunça dos dados brutos:

- **ETL (Pandas) e o Join Híbrido:** Percebi que os arquivos da ANS são inconsistentes: uns usam CNPJ e outros o Registro ANS. Para não perder informação no meio do caminho, criei uma lógica que tenta o cruzamento por CNPJ e, se falhar, usa o Registro como "plano B". Isso garantiu a integridade total da base.
- **SQL (CTEs e Joins):** Nas queries SQL, fiz questão de seguir o padrão que aprendi na faculdade, utilizando o `CAST` explícito em todas as conversões de tipos. Saíndo um pouco da facilidade de usar atalhos específicos de um banco só, essa abordagem deixa o código mais 'limpo' e profissional, além de evitar erros de compatibilidade entre o CNPJ das despesas e o Registro das operadoras. É aquela ideia de garantir que a base seja sólida antes de construir o dashboard por cima.
- **API REST:** Deixei uma coleção do Postman pronta na pasta `/docs`. Ela mostra todo o ecossistema da API: desde a listagem simples até os endpoints analíticos que alimentam o dashboard.

## **5.1 Documentação da API (Postman)**

Para facilitar a validação das rotas e entender a estrutura dos dados retornados, incluí uma coleção completa do Postman.

**Como importar e testar:**

1. Abra o **Postman**.
2. Clique no botão **Import** (canto superior esquerdo).
3. Arraste o arquivo `ANSDashboard-CaseIntuitiveCare.json` localizado na pasta `/docs`.

## 6. Frontend e Visualização

O dashboard foi montado com **Vue.js 3** e **Chart.js**, focando em transformar números em impacto visual.

- **O Desafio da Reatividade:** Um problema comum em dashboards é o gráfico aparecer vazio enquanto os dados carregam. Para resolver isso, usei uma "chave de reatividade": o componente do gráfico só "nasce" de verdade quando a API confirma que o dado chegou. Assim, a experiência visual é sempre limpa e sem aquele frame em branco que confunde o usuário.